<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Complexe_categories">
<Heading>Complexe categories</Heading>

<Section Label="Chapter_Complexe_categories_Section_Chain_and_cochain_complex_categories">
<Heading>Chain and cochain complex categories</Heading>

<ManSection>
  <Filt Arg="arg" Name="IsChainOrCochainComplexCategory" Label="for IsCapCategory"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Filt Arg="arg" Name="IsChainComplexCategory" Label="for IsChainOrCochainComplexCategory"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Filt Arg="arg" Name="IsCochainComplexCategory" Label="for IsChainOrCochainComplexCategory"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="A" Name="ChainComplexCategory" Label="for IsCapCategory"/>
 <Returns>a CAP category
</Returns>
 <Description>
Creates the chain complex category <A>Ch(A)</A> an Abelian category <A>A</A>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="A" Name="CochainComplexCategory" Label="for IsCapCategory"/>
 <Returns>a CAP category
</Returns>
 <Description>
Creates the cochain complex category <A>CoCh(A)</A> an Abelian category <A>A</A>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="B" Name="UnderlyingCategory" Label="for IsChainOrCochainComplexCategory"/>
 <Returns>a CAP category
</Returns>
 <Description>
The input is a chain or cochain complex category <A>B=C(A)</A> constructed by one of the previous commands.
The outout is <A>A</A>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Complexe_categories_Section_Chain_and_cochain_complexes">
<Heading>Chain and cochain complexes</Heading>

<ManSection>
  <Filt Arg="arg" Name="IsChainOrCochainComplex" Label="for IsCapCategoryObject"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Filt Arg="arg" Name="IsChainComplex" Label="for IsChainOrCochainComplex"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Filt Arg="arg" Name="IsCochainComplex" Label="for IsChainOrCochainComplex"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="A, diffs" Name="ChainComplexByDifferentialList" Label="for IsCapCategory, IsZList"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is category <A>A</A> and an infinite list <A>diffs</A>. The output is the chain complex <Math>M_{\bullet}\in \mathrm{Ch}(A)</Math> where <Math>d^M_{i}=\mathrm{diffs}[ i ]</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="A, diffs" Name="CochainComplexByDifferentialList" Label="for IsCapCategory, IsZList"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is category <A>A</A> and an infinite list <A>diffs</A>. The output is the cochain complex <Math>M^{\bullet}\in \mathrm{Ch}(A)</Math> where <Math>d_M^{i}=\mathrm{diffs}[ i ]</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="diffs, n" Name="FiniteChainComplex" Label="for IsDenseList, IsInt"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is a finite dense list <A>diffs</A> and an integer <A>n</A> . The output is the chain complex <Math>M_{\bullet}\in \mathrm{Ch}(A)</Math> where
<Math>d^M_{n}=\mathrm{diffs}[ 1 ],d^M_{n+1}=\mathrm{diffs}[ 2 ],</Math> etc..
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="diffs" Name="FiniteChainComplex" Label="for IsDenseList"/>
 <Returns>a chain complex
</Returns>
 <Description>
The same as the previous command with <A>n=0</A>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="diffs, n" Name="FiniteCochainComplex" Label="for IsDenseList, IsInt"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is a finite dense list <A>diffs</A> and an integer <A>n</A> . The output is the chain complex <Math>M^{\bullet}\in \mathrm{CoCh}(A)</Math> where
<Math>d_M^{n}=\mathrm{diffs}[ 1 ],d_M^{n+1}=\mathrm{diffs}[ 2 ],</Math> etc..
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="diffs" Name="FiniteCochainComplex" Label="for IsDenseList"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The same as the previous command with <A>n=0</A>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Complexe_categories_Section_Functors">
<Heading>Functors</Heading>

<ManSection>
  <Oper Arg="A,n" Name="HomologyAsFunctor" Label="for IsCapCategory, IsInt"/>
 <Returns>a functor
</Returns>
 <Description>
The input is an Abelian category <A>A</A> and an integer <A>n</A>. The output is the <Math>n</Math>-th homology functor
<Math>H_n:\mathrm{Ch}(A) \rightarrow A</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="A,n" Name="CohomologyAsFunctor" Label="for IsCapCategory, IsInt"/>
 <Returns>a functor
</Returns>
 <Description>
The input is an Abelian category <A>A</A> and an integer <A>n</A>. The output is the <Math>n</Math>-th cohomology functor
<Math>H^n:\mathrm{CoCh}(A) \rightarrow A</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C(A), n" Name="ShiftAsFunctor" Label="for IsCapCategory, IsInt"/>
 <Returns>a functor
</Returns>
 <Description>
The input is a complex category <A>C=C(A)</A> and an integer <A>n</A>. The output is the the shift functor
<Math>T[n]:C \rightarrow C</Math>, defined by <Math>M\mapsto M[n]</Math> for complexes and by <Math>\phi\mapsto \phi[n]</Math> for maps. In chain complex category we have <Math>M[n]_i=M_{n+i}, d_{i}^{M[n]}=(-1)^{n}d_{n+i}^{M}</Math>
for any chain complex <Math>M\in C</Math> and <Math>\phi[n]_i=\phi_{n+i}</Math> for any chain map <Math>\phi\in C</Math>. The same holds in the cochain complex category, i.e.,
<Math>M[n]^i=M^{n+i}, d^{i}_{M[n]}=(-1)^{n}d^{n+i}_{M}</Math> and <Math>\phi[n]^i=\phi^{n+i}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C(A), n" Name="UnsignedShiftAsFunctor" Label="for IsCapCategory, IsInt"/>
 <Returns>a functor
</Returns>
 <Description>
The input is a complex category <A>C=C(A)</A> and an integer <A>n</A>. The output is the the shift functor
<Math>S[n]:C \rightarrow C</Math>, defined by <Math>M\mapsto S[n](M)</Math> for complexes and by <Math>\phi\mapsto S[n](\phi)</Math> for maps. In chain complex category we have <Math>(S[n](M))_i=M_{n+i}, d_{i}^{S[n](M)}=d_{n+i}^{M}</Math>
for any chain complex <Math>M\in C</Math> and <Math>\phi[n]_i=\phi_{n+i}</Math> for any chain map <Math>\phi\in C</Math>. The same holds in the cochain complex category, i.e.,
<Math>(S[n](M))^i=M^{n+i}, d^{i}_{S[n](M)}=d^{n+i}_{M}</Math> and <Math>\phi[n]^i=\phi^{n+i}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="A" Name="ChainToCochainComplexAsFunctor" Label="for IsCapCategory"/>
 <Returns>a functor
</Returns>
 <Description>
The input is a category <A>A</A>. The output is the functor <Math>F:\mathrm{Ch(A)}\rightarrow\mathrm{CoCh(A)}</Math> defined by <Math>M_{\bullet}\mapsto M^{\bullet}</Math> for any
for any chain complex <Math>M_{\bullet}\in \mathrm{Ch}(A)</Math> and by <Math>\phi_{\bullet}\mapsto \phi^{\bullet}</Math> for any map <Math>\phi</Math> where <Math>M^{i}=M_{-i}</Math> and <Math>\phi^{i}=\phi_{-i}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="A" Name="CochainToChainComplexAsFunctor" Label="for IsCapCategory"/>
 <Returns>a functor
</Returns>
 <Description>
The input is a category <A>A</A>. The output is the functor <Math>F:\mathrm{CoCh(A)}\rightarrow\mathrm{Ch(A)}</Math> defined by <Math>M^{\bullet}\mapsto M_{\bullet}</Math> for any
cochain complex <Math>M^{\bullet}\in \mathrm{CoCh}(A)</Math> and by <Math>\phi^{\bullet}\mapsto \phi_{\bullet}</Math> for any map <Math>\phi</Math> where <Math>M_{i}=M^{-i}</Math> and <Math>\phi_{i}=\phi^{-i}</Math>.
 </Description>
</ManSection>


</Section>


</Chapter>

