<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Working_with_complexes">
<Heading>Working with complexes</Heading>

<Section Label="Chapter_Working_with_complexes_Section_Filters">
<Heading>Filters</Heading>

<ManSection>
  <Filt Arg="arg" Name="IsChainOrCochainComplex" Label="for IsCapCategoryObject"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Filt Arg="arg" Name="IsChainComplex" Label="for IsChainOrCochainComplex"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


<ManSection>
  <Filt Arg="arg" Name="IsCochainComplex" Label="for IsChainOrCochainComplex"/>
 <Returns><C>true</C> or <C>false</C>
</Returns>
 <Description>
bla bla
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Working_with_complexes_Section_Creating_chain_and_cochain_complexes">
<Heading>Creating chain and cochain complexes</Heading>

<ManSection>
  <Oper Arg="A, diffs" Name="ChainComplexByDifferentialList" Label="for IsCapCategory, IsZList"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is category <A>A</A> and an infinite list <A>diffs</A>. The output is the chain complex <Math>M_{\bullet}\in \mathrm{Ch}(A)</Math> where <Math>d^M_{i}=\mathrm{diffs}[ i ]</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="A, diffs" Name="CochainComplexByDifferentialList" Label="for IsCapCategory, IsZList"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is category <A>A</A> and an infinite list <A>diffs</A>. The output is the cochain complex <Math>M^{\bullet}\in \mathrm{Ch}(A)</Math> where <Math>d_M^{i}=\mathrm{diffs}[ i ]</Math>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> S := HomalgFieldOfRationalsInSingular()*"x,y,z";;
gap> left_pre_cat := LeftPresentations( S );
Category of left presentations of Q[x,y,z]
gap> cochain_cat := CochainComplexCategory ( left_pre_cat );
Cochain complexes category over Category of left presentations of Q[x,y,z]
gap> m := HomalgMatrix( "[ [ x,y ], [ y, z ], [ 0, x ] ]", 3, 2, S );
<A 3 x 2 matrix over an external ring>
gap> n := HomalgMatrix( "[ [ x, y, z ], [ 0, x, 1 ] ]", 2, 3, S );    
<A 2 x 3 matrix over an external ring>
gap> M := AsLeftPresentation( m );
<An object in Category of left presentations of Q[x,y,z]>
gap> N := AsLeftPresentation( n );
<An object in Category of left presentations of Q[x,y,z]>
gap> f := PresentationMorphism( M, 
> HomalgMatrix( "[ [ x, y, z ], [ 0, 0, 0 ] ]", 2, 3, S ), N );
<A morphism in Category of left presentations of Q[x,y,z]>
gap> g := CokernelProjection( f );
<An epimorphism in Category of left presentations of Q[x,y,z]>
gap> T := CokernelObject( f );
<An object in Category of left presentations of Q[x,y,z]>
gap> h := ZeroMorphism( T, M );
<A zero morphism in Category of left presentations of Q[x,y,z]>
]]></Example>


Let us define the cochain complex
<Alt Only="LaTeX"><![CDATA[
\begin{center}
\begin{tikzpicture}
\matrix (m) [matrix of math nodes,row sep=1em,column sep=3em,minimum width=2em]
{
& -1 & 0 & 1 & 2 & 3 & 4 \\
C_1:\cdots & M & N & T & M & N & T & \cdots \\};
\path[-stealth]
(m-2-1) edge node[above] {$h$} (m-2-2)
(m-2-2) edge node[above] {$f$} (m-2-3)
(m-2-3) edge node[above] {$g$} (m-2-4)
(m-2-4) edge node[above] {$h$} (m-2-5)
(m-2-5) edge node[above] {$f$} (m-2-6)
(m-2-6) edge node[above] {$g$} (m-2-7)
(m-2-7) edge node[above] {$h$} (m-2-8);
\end{tikzpicture}
\end{center}
]]></Alt>
<Example><![CDATA[
gap> l := RepeatListZ( [ g, h, f ] );;
gap> C1 := CochainComplexByDifferentialList( left_pre_cat, l );
<An object in Cochain complexes category over Category of left presentations 
of Q[x,y,z]>
gap> Display( C1^0 );
1,0,0,
0,1,0,
0,0,1 

An epimorphism in Category of left presentations of Q[x,y,z]
gap> Display( C1^-1 );
x,y,z,
0,0,0 

A morphism in Category of left presentations of Q[x,y,z]
gap> Display( C1[ 3 ] );
x,y,z,
0,x,1 

An object in Category of left presentations of Q[x,y,z]
gap> objs := Objects( C1 );          
<An infinit list>
gap> diffs := Differentials( C1 );
<An infinit list>
gap> diffs[ 100 ] = C1^100;
true
]]></Example>



<ManSection>
  <Oper Arg="diffs, n" Name="FiniteChainComplex" Label="for IsDenseList, IsInt"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is a finite dense list <A>diffs</A> and an integer <A>n</A> . The output is the chain complex <Math>M_{\bullet}\in \mathrm{Ch}(A)</Math> where
<Math>d^M_{n}=\mathrm{diffs}[ 1 ],d^M_{n+1}=\mathrm{diffs}[ 2 ],</Math> etc..
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="diffs" Name="FiniteChainComplex" Label="for IsDenseList"/>
 <Returns>a chain complex
</Returns>
 <Description>
The same as the previous command with <A>n=0</A>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="diffs, n" Name="FiniteCochainComplex" Label="for IsDenseList, IsInt"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is a finite dense list <A>diffs</A> and an integer <A>n</A> . The output is the chain complex <Math>M^{\bullet}\in \mathrm{CoCh}(A)</Math> where
<Math>d_M^{n}=\mathrm{diffs}[ 1 ],d_M^{n+1}=\mathrm{diffs}[ 2 ],</Math> etc..
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="diffs" Name="FiniteCochainComplex" Label="for IsDenseList"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The same as the previous command with <A>n=0</A>.
 </Description>
</ManSection>


Let us constructe the finite cochain map
<Alt Only="LaTeX"><![CDATA[
\begin{center}
\begin{tikzpicture}
\matrix (m) [matrix of math nodes,row sep=1em,column sep=3em,minimum width=2em]
{
\cdots\;13 & 14 & 15 & 16 & 17 & 18 & 19 & \cdots\\
C_2:0 & N & T & M & N & T & 0 & 0 \\};
\path[-stealth]
(m-2-1) edge (m-2-2)
(m-2-2) edge node[above] {$g$} (m-2-3)
(m-2-3) edge node[above] {$h$} (m-2-4)
(m-2-4) edge node[above] {$f$} (m-2-5)
(m-2-5) edge node[above] {$g$} (m-2-6)
(m-2-6) edge (m-2-7)
(m-2-7) edge (m-2-8);
\end{tikzpicture}
\end{center}
]]></Alt>
<Example><![CDATA[
gap> C2 := FiniteCochainComplex( [ g, h, f, g ], 14 );
<A bounded object in Cochain complexes category over Category of left 
presentations of Q[x,y,z]>
gap> C2[ 29 ];
<A zero object in Category of left presentations of Q[x,y,z]>
gap> C2[ -100 ];
<A zero object in Category of left presentations of Q[x,y,z]>
gap> ActiveUpperBound( C2 );
19
gap> ActiveLowerBound( C2 );
13
]]></Example>



<ManSection>
  <Oper Arg="M" Name="StalkChainComplex" Label="for IsCapCategoryObject"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is an object <Math>M\in A</Math>. The output is chain complex <Math>M_{\bullet}\in\mathrm{Ch(A)}</Math> where <Math>M_0=M</Math> and <Math>M_i=0</Math> whenever <Math>i\neq 0</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="M" Name="StalkCochainComplex" Label="for IsCapCategoryObject"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is an object <Math>M\in A</Math>. The output is cochain complex <Math>M^{\bullet}\in\mathrm{CoCh(A)}</Math> where <Math>M^0=M</Math> and <Math>M^i=0</Math> whenever <Math>i\neq 0</Math>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> chain_N := StalkChainComplex( N );
<A bounded object in Chain complexes category over Category of left 
presentations of Q[x,y,z]>
gap> chain_N^0;
<A zero, split epimorphism in Category of left presentations of Q[x,y,z]>
gap> Source( chain_N^0 ) = N;
true
gap> Range( chain_N^1 ) = N;
true
gap> cochain_N := StalkCochainComplex( N );
<A bounded object in Cochain complexes category over Category of left 
presentations of Q[x,y,z]>
gap> Source( cochain_N^0 ) = N;
true
gap> Range( cochain_N^-1 ) = N;
true
gap> ActiveLowerBound( cochain_N );
-1
gap> ActiveUpperBound( cochain_N );
1
]]></Example>



<ManSection>
  <Oper Arg="d,G,F" Name="ChainComplexWithInductiveSides" Label="for IsCapCategoryMorphism, IsFunction, IsFunction"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is a morphism <Math>d\in A</Math> and two functions <Math>F,G</Math>.
The output is chain complex <Math>M_{\bullet}\in\mathrm{Ch(A)}</Math> where <Math>d^{M}_{0}=d</Math>
and <Math>d^M_{i}=G^{i}( d )</Math> for all <Math>i\leq -1</Math> and <Math>d^M_{i}=F^{i}( d )</Math> for all <Math>i \geq 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="d,G,F" Name="CochainComplexWithInductiveSides" Label="for IsCapCategoryMorphism, IsFunction, IsFunction"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is a morphism <Math>d\in A</Math> and two functions <Math>F,G</Math>.
The output is cochain complex <Math>M^{\bullet}\in\mathrm{CoCh(A)}</Math> where <Math>d_{M}^{0}=d</Math>
and <Math>d_M^{i}=G^{i}( d )</Math> for all <Math>i\leq -1</Math> and <Math>d_M^{i}=F^{i}( d )</Math> for all <Math>i \geq 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="d,G" Name="ChainComplexWithInductiveNegativeSide" Label="for IsCapCategoryMorphism, IsFunction"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is a morphism <Math>d\in A</Math> and a functions <Math>G</Math>.
The output is chain complex <Math>M_{\bullet}\in\mathrm{Ch(A)}</Math> where <Math>d^{M}_{0}=d</Math>
and <Math>d^M_{i}=G^{i}( d )</Math> for all <Math>i\leq -1</Math> and <Math>d^M_{i}=0</Math> for all <Math>i \geq 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="d,F" Name="ChainComplexWithInductivePositiveSide" Label="for IsCapCategoryMorphism, IsFunction"/>
 <Returns>a chain complex
</Returns>
 <Description>
The input is a morphism <Math>d\in A</Math> and a functions <Math>F</Math>.
The output is chain complex <Math>M_{\bullet}\in\mathrm{Ch(A)}</Math> where <Math>d^{M}_{0}=d</Math>
and <Math>d^M_{i}=F^{i}( d )</Math> for all <Math>i\geq 1</Math> and <Math>d^M_{i}=0</Math> for all <Math>i \leq 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="d,G" Name="CochainComplexWithInductiveNegativeSide" Label="for IsCapCategoryMorphism, IsFunction"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is a morphism <Math>d\in A</Math> and a functions <Math>G</Math>.
The output is cochain complex <Math>M^{\bullet}\in\mathrm{CoCh(A)}</Math> where <Math>d_{M}^{0}=d</Math>
and <Math>d_M^{i}=G^{i}( d )</Math> for all <Math>i\leq -1</Math> and <Math>d_M^{i}=0</Math> for all <Math>i \geq 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="d,F" Name="CochainComplexWithInductivePositiveSide" Label="for IsCapCategoryMorphism, IsFunction"/>
 <Returns>a cochain complex
</Returns>
 <Description>
The input is a morphism <Math>d\in A</Math> and a functions <Math>F</Math>.
The output is cochain complex <Math>M^{\bullet}\in\mathrm{CoCh(A)}</Math> where <Math>d_{M}^{0}=d</Math>
and <Math>d_M^{i}=F^{i}( d )</Math> for all <Math>i\geq 1</Math> and <Math>d_M^{i}=0</Math> for all <Math>i \leq 1</Math>.
 </Description>
</ManSection>


To illustrate this let us constructe the free (projective) resolution of M as a chain complex.
<Example><![CDATA[
gap> d0 := UniversalMorphismIntoZeroObject( M );
<A zero, split epimorphism in Category of left presentations of Q[x,y,z]> 
gap> inductive_function := function( mor ) local ker_embedding, cover;ker_embedding := KernelEmbedding( mor );cover := CoverByFreeModule( Source( ker_embedding ) );return PreCompose( cover, ker_embedding );end;;
gap> proj_M := ChainComplexWithInductivePositiveSide( d0, inductive_function );
<A bounded from bellow object in Chain complexes category over Category of left 
presentations of Q[x,y,z]>
gap> Display( proj_M, 0, 4 );
-----------------------------------------------------------------
In index 0

Object[ 0 ] is
x,y,
y,z,
0,x 

An object in Category of left presentations of Q[x,y,z]

Differential[ 0 ] is
(an empty 2 x 0 matrix)

A zero, split epimorphism in Category of left presentations of Q[x,y,z]
-----------------------------------------------------------------
In index 1

Object[ 1 ] is
(an empty 0 x 2 matrix)

An object in Category of left presentations of Q[x,y,z]

Differential[ 1 ] is
1,0,
0,1 

A morphism in Category of left presentations of Q[x,y,z]
-----------------------------------------------------------------
In index 2

Object[ 2 ] is
(an empty 0 x 3 matrix)

An object in Category of left presentations of Q[x,y,z]

Differential[ 2 ] is
x,y,
y,z,
0,x 

A morphism in Category of left presentations of Q[x,y,z]
-----------------------------------------------------------------
In index 3

Object[ 3 ] is
(an empty 0 x 1 matrix)

An object in Category of left presentations of Q[x,y,z]

Differential[ 3 ] is
-x*y,x^2,y^2-x*z

A morphism in Category of left presentations of Q[x,y,z]
-----------------------------------------------------------------
In index 4

Object[ 4 ] is
(an empty 0 x 0 matrix)

An object in Category of left presentations of Q[x,y,z]

Differential[ 4 ] is
(an empty 0 x 1 matrix)

A morphism in Category of left presentations of Q[x,y,z]
]]></Example>



</Section>


<Section Label="Chapter_Working_with_complexes_Section_Attributes_and_operations_on_complexes">
<Heading>Attributes and operations on complexes.</Heading>

<ManSection Label="1">
  <Attr Arg="C" Name="Differentials" Label="for IsChainOrCochainComplex"/>
  <Attr Arg="C" Name="DifferentialsOfComplex" Label="for IsChainOrCochainComplex"/>
 <Returns>an infinite list
</Returns>
 <Description>
Both commands return the differentials of the chain or cochain complex as an infinite list.
 </Description>
</ManSection>


<ManSection Label="2">
  <Attr Arg="C" Name="Objects" Label="for IsChainOrCochainComplex"/>
  <Attr Arg="C" Name="ObjectsOfChainComplex" Label="for IsChainComplex"/>
  <Attr Arg="C" Name="ObjectsOfCochainComplex" Label="for IsCochainComplex"/>
 <Returns>an infinite list
</Returns>
 <Description>
All commands return the objects of the chain or cochain complex as an infinite list.
<Br/>
 </Description>
</ManSection>


<ManSection Label="3">
  <Oper Arg="C, i" Name="ObjectOfComplex" Label="for IsChainOrCochainComplex, IsInt"/>
  <Oper Arg="C, i" Name="\[\]" Label="for IsChainOrCochainComplex, IsInt"/>
 <Returns>an object
</Returns>
 <Description>
Both commands return the object of the chain or cochain complex in index <Math>i</Math>.
 </Description>
</ManSection>


<ManSection Label="4">
  <Oper Arg="C, i" Name="DifferentialOfComplex" Label="for IsChainOrCochainComplex, IsInt"/>
  <Oper Arg="C, i" Name="\^" Label="for IsChainOrCochainComplex, IsInt"/>
 <Returns>a morphism
</Returns>
 <Description>
Both commands return the differential of the chain or cochain complex in index <Math>i</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, n" Name="DefectOfExactness" Label="for IsChainOrCochainComplex, IsInt"/>
 <Returns>a object
</Returns>
 <Description>
The input is a chain or cochain complex <Math>C</Math> and an integer <Math>n</Math>. The outout is the homology(cohomology) object of <Math>C</Math> in index <Math>n</Math> if <Math>C</Math> is chain(cochain) complex.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, n" Name="IsExactInIndex" Label="for IsChainOrCochainComplex, IsInt"/>
 <Returns>true or false
</Returns>
 <Description>
The input is a chain or cochain complex <Math>C</Math> and an integer <Math>n</Math>. The outout is <A>true</A> if <Math>C</Math> is exact in <Math>i</Math>. Otherwise the output is <A>false</A>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, n" Name="SetUpperBound" Label="for IsChainOrCochainComplex, IsInt"/>
 <Returns>a nothing
</Returns>
 <Description>
The command sets an upper bound <Math>n</Math> to the chain(cochain) complex <Math>C</Math>. This means <Math>C_{i\geq n}=0(C^{\geq n}=0)</Math>. This upper bound will be called <Math>\textit{active}</Math> upper bound and it can be changed whenever it is needed.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, n" Name="SetLowerBound" Label="for IsChainOrCochainComplex, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
The command sets a lower bound <Math>n</Math> to the chain(cochain) complex <Math>C</Math>. This means <Math>C_{i \leq n}=0(C^{i \leq n}=0)</Math>.
This lower bound will be called <Math>\textit{active}</Math> lower bound and it can be changed whenever it is needed.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C" Name="HasActiveUpperBound" Label="for IsChainOrCochainComplex"/>
 <Returns>true or false
</Returns>
 <Description>
The input is chain or cochain complex. The output is <A>true</A> if an upper bound has been set to <Math>C</Math> and <A>false</A> otherwise.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C" Name="HasActiveLowerBound" Label="for IsChainOrCochainComplex"/>
 <Returns>true or false
</Returns>
 <Description>
The input is chain or cochain complex. The output is <A>true</A> if a lower bound has been set to <Math>C</Math> and <A>false</A> otherwise.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C" Name="ActiveUpperBound" Label="for IsChainOrCochainComplex"/>
 <Returns>an integer
</Returns>
 <Description>
The input is chain or cochain complex. The output is its active upper bound if such has been set to <Math>C</Math>. Otherwise we get error.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C" Name="ActiveLowerBound" Label="for IsChainOrCochainComplex"/>
 <Returns>an integer
</Returns>
 <Description>
The input is chain or cochain complex. The output is its active lower bound if such has been set to <Math>C</Math>. Otherwise we get error.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, m, n" Name="Display" Label="for IsChainOrCochainComplex, IsInt, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
The input is chain or cochain complex <Math>C</Math> and two integers <Math>m</Math> and <Math>n</Math>. The command displays all components of <Math>C</Math> between the indices <Math>m,n</Math>.
 </Description>
</ManSection>


</Section>


</Chapter>

